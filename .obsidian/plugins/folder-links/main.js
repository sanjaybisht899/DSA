/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => FolderLinksPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/constants.ts
var RESOLVED_LINK_CLASS = "is-resolved";
var UNRESOLVED_LINK_CLASS = "is-unresolved";

// src/editor-extension/FolderStateField.ts
var import_state = require("@codemirror/state");
var updateEffect = import_state.StateEffect.define();
var resetEffect = import_state.StateEffect.define();
var globalCurrentFolders = null;
var setGlobalFolderState = (folders) => {
  globalCurrentFolders = folders;
};
var folderField = import_state.StateField.define({
  create(_state) {
    const initialState = globalCurrentFolders || { raw: [], asPathes: [] };
    return initialState;
  },
  update(oldState, transaction) {
    let newState = oldState;
    for (let effect of transaction.effects) {
      if (effect.is(updateEffect)) {
        newState = effect.value;
        globalCurrentFolders = effect.value;
      } else if (effect.is(resetEffect)) {
        newState = { raw: [], asPathes: [] };
        globalCurrentFolders = { raw: [], asPathes: [] };
      }
    }
    return newState;
  }
});

// src/editor-extension/FolderUpdater.ts
var import_view = require("@codemirror/view");
var folderUpdater = (folderObservable) => {
  folderObservable.subscribe((folders) => {
    setGlobalFolderState(folders);
  });
  return import_view.EditorView.updateListener.of((update) => {
    if (!update.view.dom.dataset.folderRegistered) {
      update.view.dom.dataset.folderRegistered = "true";
      folderObservable.subscribe((folders) => {
        if (update.view.dom.isConnected) {
          update.view.dispatch({
            effects: [updateEffect.of(folders)]
          });
        }
      });
    }
  });
};

// src/editor-extension/MarkFolderLink.ts
var import_view2 = require("@codemirror/view");
var import_state2 = require("@codemirror/state");
var import_language = require("@codemirror/language");

// node_modules/.pnpm/zen-observable-ts@1.1.0/node_modules/zen-observable-ts/module.js
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
  if (it)
    return (it = it.call(o)).next.bind(it);
  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
    if (it)
      o = it;
    var i = 0;
    return function() {
      if (i >= o.length)
        return { done: true };
      return { done: false, value: o[i++] };
    };
  }
  throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
var hasSymbols = function() {
  return typeof Symbol === "function";
};
var hasSymbol = function(name) {
  return hasSymbols() && Boolean(Symbol[name]);
};
var getSymbol = function(name) {
  return hasSymbol(name) ? Symbol[name] : "@@" + name;
};
if (hasSymbols() && !hasSymbol("observable")) {
  Symbol.observable = Symbol("observable");
}
var SymbolIterator = getSymbol("iterator");
var SymbolObservable = getSymbol("observable");
var SymbolSpecies = getSymbol("species");
function getMethod(obj, key) {
  var value = obj[key];
  if (value == null)
    return void 0;
  if (typeof value !== "function")
    throw new TypeError(value + " is not a function");
  return value;
}
function getSpecies(obj) {
  var ctor = obj.constructor;
  if (ctor !== void 0) {
    ctor = ctor[SymbolSpecies];
    if (ctor === null) {
      ctor = void 0;
    }
  }
  return ctor !== void 0 ? ctor : Observable;
}
function isObservable(x) {
  return x instanceof Observable;
}
function hostReportError(e) {
  if (hostReportError.log) {
    hostReportError.log(e);
  } else {
    setTimeout(function() {
      throw e;
    });
  }
}
function enqueue(fn) {
  Promise.resolve().then(function() {
    try {
      fn();
    } catch (e) {
      hostReportError(e);
    }
  });
}
function cleanupSubscription(subscription) {
  var cleanup = subscription._cleanup;
  if (cleanup === void 0)
    return;
  subscription._cleanup = void 0;
  if (!cleanup) {
    return;
  }
  try {
    if (typeof cleanup === "function") {
      cleanup();
    } else {
      var unsubscribe = getMethod(cleanup, "unsubscribe");
      if (unsubscribe) {
        unsubscribe.call(cleanup);
      }
    }
  } catch (e) {
    hostReportError(e);
  }
}
function closeSubscription(subscription) {
  subscription._observer = void 0;
  subscription._queue = void 0;
  subscription._state = "closed";
}
function flushSubscription(subscription) {
  var queue = subscription._queue;
  if (!queue) {
    return;
  }
  subscription._queue = void 0;
  subscription._state = "ready";
  for (var i = 0; i < queue.length; ++i) {
    notifySubscription(subscription, queue[i].type, queue[i].value);
    if (subscription._state === "closed")
      break;
  }
}
function notifySubscription(subscription, type, value) {
  subscription._state = "running";
  var observer = subscription._observer;
  try {
    var m = getMethod(observer, type);
    switch (type) {
      case "next":
        if (m)
          m.call(observer, value);
        break;
      case "error":
        closeSubscription(subscription);
        if (m)
          m.call(observer, value);
        else
          throw value;
        break;
      case "complete":
        closeSubscription(subscription);
        if (m)
          m.call(observer);
        break;
    }
  } catch (e) {
    hostReportError(e);
  }
  if (subscription._state === "closed")
    cleanupSubscription(subscription);
  else if (subscription._state === "running")
    subscription._state = "ready";
}
function onNotify(subscription, type, value) {
  if (subscription._state === "closed")
    return;
  if (subscription._state === "buffering") {
    subscription._queue.push({
      type,
      value
    });
    return;
  }
  if (subscription._state !== "ready") {
    subscription._state = "buffering";
    subscription._queue = [{
      type,
      value
    }];
    enqueue(function() {
      return flushSubscription(subscription);
    });
    return;
  }
  notifySubscription(subscription, type, value);
}
var Subscription = /* @__PURE__ */ function() {
  function Subscription2(observer, subscriber) {
    this._cleanup = void 0;
    this._observer = observer;
    this._queue = void 0;
    this._state = "initializing";
    var subscriptionObserver = new SubscriptionObserver(this);
    try {
      this._cleanup = subscriber.call(void 0, subscriptionObserver);
    } catch (e) {
      subscriptionObserver.error(e);
    }
    if (this._state === "initializing")
      this._state = "ready";
  }
  var _proto = Subscription2.prototype;
  _proto.unsubscribe = function unsubscribe() {
    if (this._state !== "closed") {
      closeSubscription(this);
      cleanupSubscription(this);
    }
  };
  _createClass(Subscription2, [{
    key: "closed",
    get: function() {
      return this._state === "closed";
    }
  }]);
  return Subscription2;
}();
var SubscriptionObserver = /* @__PURE__ */ function() {
  function SubscriptionObserver2(subscription) {
    this._subscription = subscription;
  }
  var _proto2 = SubscriptionObserver2.prototype;
  _proto2.next = function next(value) {
    onNotify(this._subscription, "next", value);
  };
  _proto2.error = function error(value) {
    onNotify(this._subscription, "error", value);
  };
  _proto2.complete = function complete() {
    onNotify(this._subscription, "complete");
  };
  _createClass(SubscriptionObserver2, [{
    key: "closed",
    get: function() {
      return this._subscription._state === "closed";
    }
  }]);
  return SubscriptionObserver2;
}();
var Observable = /* @__PURE__ */ function() {
  function Observable2(subscriber) {
    if (!(this instanceof Observable2))
      throw new TypeError("Observable cannot be called as a function");
    if (typeof subscriber !== "function")
      throw new TypeError("Observable initializer must be a function");
    this._subscriber = subscriber;
  }
  var _proto3 = Observable2.prototype;
  _proto3.subscribe = function subscribe(observer) {
    if (typeof observer !== "object" || observer === null) {
      observer = {
        next: observer,
        error: arguments[1],
        complete: arguments[2]
      };
    }
    return new Subscription(observer, this._subscriber);
  };
  _proto3.forEach = function forEach(fn) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      if (typeof fn !== "function") {
        reject(new TypeError(fn + " is not a function"));
        return;
      }
      function done() {
        subscription.unsubscribe();
        resolve();
      }
      var subscription = _this.subscribe({
        next: function(value) {
          try {
            fn(value, done);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  };
  _proto3.map = function map(fn) {
    var _this2 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      return _this2.subscribe({
        next: function(value) {
          try {
            value = fn(value);
          } catch (e) {
            return observer.error(e);
          }
          observer.next(value);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.filter = function filter(fn) {
    var _this3 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      return _this3.subscribe({
        next: function(value) {
          try {
            if (!fn(value))
              return;
          } catch (e) {
            return observer.error(e);
          }
          observer.next(value);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          observer.complete();
        }
      });
    });
  };
  _proto3.reduce = function reduce(fn) {
    var _this4 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    var hasSeed = arguments.length > 1;
    var hasValue = false;
    var seed = arguments[1];
    var acc = seed;
    return new C(function(observer) {
      return _this4.subscribe({
        next: function(value) {
          var first = !hasValue;
          hasValue = true;
          if (!first || hasSeed) {
            try {
              acc = fn(acc, value);
            } catch (e) {
              return observer.error(e);
            }
          } else {
            acc = value;
          }
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          if (!hasValue && !hasSeed)
            return observer.error(new TypeError("Cannot reduce an empty sequence"));
          observer.next(acc);
          observer.complete();
        }
      });
    });
  };
  _proto3.concat = function concat() {
    var _this5 = this;
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var C = getSpecies(this);
    return new C(function(observer) {
      var subscription;
      var index = 0;
      function startNext(next) {
        subscription = next.subscribe({
          next: function(v) {
            observer.next(v);
          },
          error: function(e) {
            observer.error(e);
          },
          complete: function() {
            if (index === sources.length) {
              subscription = void 0;
              observer.complete();
            } else {
              startNext(C.from(sources[index++]));
            }
          }
        });
      }
      startNext(_this5);
      return function() {
        if (subscription) {
          subscription.unsubscribe();
          subscription = void 0;
        }
      };
    });
  };
  _proto3.flatMap = function flatMap(fn) {
    var _this6 = this;
    if (typeof fn !== "function")
      throw new TypeError(fn + " is not a function");
    var C = getSpecies(this);
    return new C(function(observer) {
      var subscriptions = [];
      var outer = _this6.subscribe({
        next: function(value) {
          if (fn) {
            try {
              value = fn(value);
            } catch (e) {
              return observer.error(e);
            }
          }
          var inner = C.from(value).subscribe({
            next: function(value2) {
              observer.next(value2);
            },
            error: function(e) {
              observer.error(e);
            },
            complete: function() {
              var i = subscriptions.indexOf(inner);
              if (i >= 0)
                subscriptions.splice(i, 1);
              completeIfDone();
            }
          });
          subscriptions.push(inner);
        },
        error: function(e) {
          observer.error(e);
        },
        complete: function() {
          completeIfDone();
        }
      });
      function completeIfDone() {
        if (outer.closed && subscriptions.length === 0)
          observer.complete();
      }
      return function() {
        subscriptions.forEach(function(s) {
          return s.unsubscribe();
        });
        outer.unsubscribe();
      };
    });
  };
  _proto3[SymbolObservable] = function() {
    return this;
  };
  Observable2.from = function from(x) {
    var C = typeof this === "function" ? this : Observable2;
    if (x == null)
      throw new TypeError(x + " is not an object");
    var method = getMethod(x, SymbolObservable);
    if (method) {
      var observable = method.call(x);
      if (Object(observable) !== observable)
        throw new TypeError(observable + " is not an object");
      if (isObservable(observable) && observable.constructor === C)
        return observable;
      return new C(function(observer) {
        return observable.subscribe(observer);
      });
    }
    if (hasSymbol("iterator")) {
      method = getMethod(x, SymbolIterator);
      if (method) {
        return new C(function(observer) {
          enqueue(function() {
            if (observer.closed)
              return;
            for (var _iterator = _createForOfIteratorHelperLoose(method.call(x)), _step; !(_step = _iterator()).done; ) {
              var item = _step.value;
              observer.next(item);
              if (observer.closed)
                return;
            }
            observer.complete();
          });
        });
      }
    }
    if (Array.isArray(x)) {
      return new C(function(observer) {
        enqueue(function() {
          if (observer.closed)
            return;
          for (var i = 0; i < x.length; ++i) {
            observer.next(x[i]);
            if (observer.closed)
              return;
          }
          observer.complete();
        });
      });
    }
    throw new TypeError(x + " is not observable");
  };
  Observable2.of = function of() {
    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      items[_key2] = arguments[_key2];
    }
    var C = typeof this === "function" ? this : Observable2;
    return new C(function(observer) {
      enqueue(function() {
        if (observer.closed)
          return;
        for (var i = 0; i < items.length; ++i) {
          observer.next(items[i]);
          if (observer.closed)
            return;
        }
        observer.complete();
      });
    });
  };
  _createClass(Observable2, null, [{
    key: SymbolSpecies,
    get: function() {
      return this;
    }
  }]);
  return Observable2;
}();
if (hasSymbols()) {
  Object.defineProperty(Observable, Symbol("extensions"), {
    value: {
      symbol: SymbolObservable,
      hostReportError
    },
    configurable: true
  });
}

// src/util.ts
function hexToDecimalRGB(hex) {
  hex = hex.replace("#", "");
  const r = parseInt(hex.substr(0, 2), 16);
  const g = parseInt(hex.substr(2, 2), 16);
  const b = parseInt(hex.substr(4, 2), 16);
  const decimal = (r << 16) + (g << 8) + b;
  return {
    decimal,
    r,
    g,
    b,
    hex
  };
}
function getPathFromFolder(folder) {
  const trimmedFolder = folder.trim();
  return trimmedFolder.substring(0, trimmedFolder.length - 1);
}
function getFolderFromPath(path) {
  const trimmedPath = path.trim();
  return trimmedPath + "/";
}
function isFolderLink(string) {
  return string.endsWith("/");
}
function debounce(source, delay) {
  return new Observable((observer) => {
    let timeoutId = null;
    const subscription = source.subscribe({
      next(value) {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
        timeoutId = setTimeout(() => {
          observer.next(value);
        }, delay);
      },
      error(err) {
        observer.error(err);
      },
      complete() {
        observer.complete();
      }
    });
    return () => {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      subscription.unsubscribe();
    };
  });
}
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// src/editor-extension/MarkFolderLink.ts
var folderMarkPlugin = import_view2.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.decorations = this.buildDecorations(view);
    }
    update(update) {
      if (update.docChanged || update.viewportChanged || update.state.field(folderField) !== update.startState.field(folderField)) {
        this.decorations = this.buildDecorations(update.view);
      }
    }
    buildDecorations(view) {
      const builder = new import_state2.RangeSetBuilder();
      const folders = view.state.field(folderField);
      let currentStart = null;
      let currentEnd = null;
      let hasAlias = false;
      for (const { from, to } of view.visibleRanges) {
        (0, import_language.syntaxTree)(view.state).iterate({
          from,
          to,
          enter(node) {
            const isInternalLink = node.type.name.includes("hmd-internal-link");
            if (!currentStart && !currentEnd && isInternalLink) {
              currentStart = node.from;
              currentEnd = node.to;
              hasAlias = node.type.name.includes("link-has-alias");
            } else if (currentStart && isInternalLink) {
              currentEnd = node.to;
            } else if (currentStart && currentEnd && !isInternalLink) {
              let currentText = view.state.doc.sliceString(currentStart, currentEnd);
              let currentHref = currentText;
              if (hasAlias) {
                const parts = currentText.split("|");
                currentHref = parts[0];
                currentText = parts[1];
              }
              if (currentHref.trim().endsWith("/")) {
                const folderPath = getPathFromFolder(currentHref.trim());
                const resolvedClass = folders.asPathes.includes(folderPath) ? "is-resolved" : "is-unresolved";
                builder.add(
                  currentStart,
                  currentEnd,
                  import_view2.Decoration.mark({
                    class: resolvedClass + " folder-link",
                    attributes: { "data-folder-link": currentHref }
                  })
                );
              }
              currentStart = null;
              currentEnd = null;
              hasAlias = false;
            }
          }
        });
      }
      return builder.finish();
    }
  },
  {
    decorations: (v) => v.decorations
  }
);

// src/error.ts
var import_obsidian = require("obsidian");
var UserHandableError = class extends Error {
};
function showErrorNotice(message) {
  new import_obsidian.Notice(`FolderLinks: Error: ${message}`);
}

// src/post-processor/FolderLinkView.ts
var import_obsidian2 = require("obsidian");
var FolderLinkView = class extends import_obsidian2.MarkdownRenderChild {
  constructor(container, targets) {
    super(container);
    this.targets = targets;
  }
  onload() {
    this.render();
  }
  render() {
    this.targets.forEach((target) => {
      if (!target.dataset.href && !target.dataset.folderLink || !FolderLinkView.folders) {
        return;
      }
      let folderPath;
      if (target.dataset.href) {
        folderPath = getPathFromFolder(target.dataset.href);
        target.dataset.folderLink = target.dataset.href;
      } else if (target.dataset.folderLink) {
        folderPath = getPathFromFolder(target.dataset.folderLink);
      } else {
        return;
      }
      if (FolderLinkView.folders.asPathes.includes(folderPath)) {
        target.addClass(RESOLVED_LINK_CLASS);
        target.removeClass(UNRESOLVED_LINK_CLASS);
        target.removeAttribute("data-href");
        target.removeAttribute("href");
        target.removeAttribute("target");
      } else {
        target.addClass(UNRESOLVED_LINK_CLASS);
        target.removeClass(RESOLVED_LINK_CLASS);
      }
    });
  }
};

// src/post-processor/FolderLinkPostProcessor.ts
var FolderLinkPostProcessor = class {
  constructor(folderObs) {
    this.folderObs = folderObs;
    this.folderLinkViews = [];
    this.folderObs.subscribe((folders) => {
      FolderLinkView.folders = folders;
      this.folderLinkViews.forEach((folderLinkView) => {
        folderLinkView.render();
      });
    });
  }
  create() {
    return (element, context) => {
      const folderLinks = element.findAll(".internal-link").filter(
        (el) => el.dataset.href && el.dataset.href.endsWith("/")
      );
      if (folderLinks && folderLinks.length) {
        const child = new FolderLinkView(
          element,
          folderLinks
        );
        context.addChild(child);
        this.folderLinkViews.push(child);
      }
    };
  }
};
var folderLinkPostProcessor = (folderObs) => new FolderLinkPostProcessor(folderObs).create();

// src/services/CorePluginService.ts
var LeafWatcher = class {
  constructor(id, initCb, cleanupCb, updateCb, allowMultiple = false) {
    this.id = id;
    this.initCb = initCb;
    this.cleanupCb = cleanupCb;
    this.updateCb = updateCb;
    this.allowMultiple = allowMultiple;
    this.instances = /* @__PURE__ */ new Set();
  }
  addInstance(instance) {
    if (!this.instances.has(instance)) {
      this.instances.add(instance);
      if (this.initCb) {
        this.initCb(instance);
        return;
      }
    } else if (this.updateCb) {
      this.updateCb(instance);
    }
  }
  removeInstance(instance) {
    if (this.instances.has(instance)) {
      if (this.cleanupCb) {
        this.cleanupCb(instance);
      }
      this.instances.delete(instance);
    }
  }
  getInstances() {
    return this.instances;
  }
  clearInstances() {
    for (const instance of this.instances) {
      if (this.cleanupCb) {
        this.cleanupCb(instance);
      }
    }
    this.instances.clear();
  }
  setInstance(instance) {
    this.addInstance(instance);
  }
  getInstance() {
    return this.instances.size === 1 ? this.instances.entries().next().value : void 0;
  }
  clearInstance() {
    this.clearInstances();
  }
};
var CorePluginService = class {
  constructor(workspace) {
    this.workspace = workspace;
    this.watchers = /* @__PURE__ */ new Map();
    this.workspace.on("active-leaf-change", (leaf) => {
      this.watchers.forEach((watcher) => {
        const found = this.workspace.getLeavesOfType(watcher.id);
        if (found && found.length === 1) {
          watcher.setInstance(found[0]);
        } else if (found.length === 0) {
          watcher.clearInstance();
        } else if (watcher.allowMultiple) {
          found.forEach((leaf2) => {
            watcher.addInstance(leaf2);
          });
        } else {
          throw Error(`More than one instance of ${watcher.id} available!`);
        }
      });
    });
  }
  getInstancesImmediate(id) {
    return this.workspace.getLeavesOfType(id);
  }
  getInstanceImmediate(id) {
    const found = this.workspace.getLeavesOfType(id);
    if (found && found.length === 1) {
      return found[0];
    } else {
      return void 0;
    }
  }
  getInstance(id) {
    var _a;
    return (_a = this.watchers.get(id)) == null ? void 0 : _a.getInstance();
  }
  getInstances(id) {
    var _a, _b;
    return (_b = (_a = this.watchers.get(id)) == null ? void 0 : _a.getInstances()) != null ? _b : /* @__PURE__ */ new Set();
  }
  registerWatcher(id, initCb, cleanupCb, updateCb, allowMultiple) {
    const instances = this.getInstancesImmediate(id);
    const leafWatcher = new LeafWatcher(id, initCb, cleanupCb, updateCb, allowMultiple);
    if (instances && instances.length > 0 && initCb) {
      instances.forEach((instance) => leafWatcher.addInstance(instance));
    }
    this.watchers.set(id, leafWatcher);
  }
  unregisterWatcher(id) {
    this.watchers.delete(id);
  }
};

// src/services/EventService.ts
var EventService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  onVaultEvent(type, callback) {
    this.plugin.registerEvent(this.plugin.app.vault.on(type, callback));
  }
  onLayoutReady(callback) {
    this.plugin.app.workspace.onLayoutReady(callback);
  }
  async waitForLayoutReady() {
    if (this.plugin.app.workspace.layoutReady) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      this.onLayoutReady(() => resolve());
    });
  }
  // bootstrap inspired event handler (source: https://github.com/twbs/bootstrap/blob/main/js/src/dom/event-handler.js)
  onDOMEvent(container, type, selector, handler, options) {
    this.plugin.registerDomEvent(
      container,
      type,
      (ev) => {
        const target = ev.target.closest(selector);
        if (target) {
          handler(target, ev);
        }
      },
      options
    );
  }
};

// src/services/FolderService.ts
var FolderService = class {
  constructor(vault, metadataCache, eventService) {
    this.vault = vault;
    this.metadataCache = metadataCache;
    this.eventService = eventService;
    this.currentValue = this.loadAll();
    this.setupObservable();
    this.observable.subscribe((value) => {
      this.currentValue = value;
    });
  }
  createFolder(path) {
    this.vault.createFolder(path);
  }
  findExistingFolderRaw(folder) {
    return this.currentValue.raw.find((f) => f === folder);
  }
  loadAll() {
    const allFolders = this.vault.getAllFolders();
    return {
      raw: allFolders,
      asPathes: allFolders.map((f) => f.path)
    };
  }
  setupObservable() {
    this.observable = debounce(
      new Observable((observer) => {
        observer.next(this.loadAll());
        this.eventService.onVaultEvent("create" /* Create */, () => {
          observer.next(this.loadAll());
        });
        this.eventService.onVaultEvent("rename" /* Rename */, () => {
          observer.next(this.loadAll());
        });
        this.eventService.onVaultEvent("delete" /* Delete */, () => {
          observer.next(this.loadAll());
        });
      }),
      50
    );
  }
  getLinkedFiles(folderPath) {
    const fileNames = /* @__PURE__ */ new Set();
    Object.entries(this.metadataCache.unresolvedLinks).forEach(([path, filesObj]) => {
      if (Object.keys(filesObj).includes(getFolderFromPath(folderPath))) {
        fileNames.add(path);
      }
    });
    return Array.from(fileNames).map((path) => this.vault.getFileByPath(path)).filter((file) => file !== null);
  }
  getFolderLinkCountInFile(file, folderPath) {
    return this.metadataCache.unresolvedLinks[file.path][getFolderFromPath(folderPath)] || 0;
  }
  getFolderLinkCountInFiles(files, folderPath) {
    return files.reduce((total, file) => {
      return total + this.getFolderLinkCountInFile(file, folderPath);
    }, 0);
  }
};

// src/services/GraphViewManager.ts
var GraphViewManager = class {
  constructor(folderService, fileExplorer) {
    this.folderService = folderService;
    this.fileExplorer = fileExplorer;
    this.instances = /* @__PURE__ */ new Set();
    this.update();
  }
  addInstance(graphView) {
    var _a;
    if (!((_a = graphView.view.dataEngine) == null ? void 0 : _a.renderer)) {
      return;
    }
    this.instances.add(graphView);
    this.updateInstance(graphView);
  }
  removeInstance(graphView) {
    this.instances.delete(graphView);
  }
  update() {
    this.instances.forEach((graphView) => {
      this.updateInstance(graphView);
    });
  }
  updateInstance(graphView) {
    var _a;
    if (!((_a = graphView.view.dataEngine) == null ? void 0 : _a.renderer)) {
      return;
    }
    const onNodeClick = graphView.view.dataEngine.renderer.onNodeClick;
    graphView.view.dataEngine.renderer.onNodeClick = (event, path) => {
      if (isFolderLink(path)) {
        const element = graphView.view.dataEngine.renderer.nodes.filter(
          (node) => node.id === path
        )[0];
        if (element._folderLink) {
          this.fileExplorer.view.revealInFolder(element._folderLink);
        } else {
          this.folderService.createFolder(path);
        }
      } else {
        onNodeClick(event, path);
      }
    };
    const graphNodeColor = getComputedStyle(document.body).getPropertyValue("--graph-node").trim();
    const nodes = Object.keys(graphView.view.dataEngine.renderer.nodeLookup);
    for (const node of nodes) {
      if (isFolderLink(node)) {
        const existingFolder = this.folderService.currentValue.raw.filter(
          (f) => f.path === getPathFromFolder(node)
        )[0];
        if (existingFolder) {
          graphView.view.dataEngine.renderer.nodeLookup[node]._folderLink = existingFolder;
          const element = graphView.view.dataEngine.renderer.nodeLookup[node];
          const renderer = graphView.view.renderer;
          graphView.view.dataEngine.renderer.nodeLookup[node].getFillColor = () => {
            var _a2;
            if (element.type === "unresolved" && ((_a2 = renderer == null ? void 0 : renderer.getHighlightNode()) == null ? void 0 : _a2.id) != element.id) {
              return { a: 1, rgb: hexToDecimalRGB(graphNodeColor).decimal };
            } else {
              return element.__proto__.getFillColor.call(element);
            }
          };
        } else {
          graphView.view.dataEngine.renderer.nodeLookup[node].getFillColor = graphView.view.dataEngine.renderer.nodeLookup[node].__proto__.getFillColor;
          graphView.view.dataEngine.renderer.nodeLookup[node]._folderLink = null;
        }
        graphView.onResize();
      }
    }
  }
};

// src/services/OutgoingLinkManager.ts
var import_obsidian3 = require("obsidian");
var OutgoingLinkmanager = class {
  constructor(translationService, folderService, outgoingLink, settings) {
    this.translationService = translationService;
    this.folderService = folderService;
    this.outgoingLink = outgoingLink;
    this.settings = settings;
    this.isUpdating = false;
    this.debouncedUpdateFolderLinks = this.debounce(() => this.updateFolderLinks(), 100);
    this.setupMutationObserver();
    this.update();
  }
  debounce(func, wait) {
    let timeout;
    return () => {
      if (timeout)
        clearTimeout(timeout);
      timeout = window.setTimeout(func, wait);
    };
  }
  setupMutationObserver() {
    const container = this.outgoingLink.view.containerEl;
    if (!container)
      return;
    this.mutationObserver = new MutationObserver(this.mutationHandler.bind(this));
    this.mutationObserver.observe(container, {
      childList: true,
      subtree: true,
      characterData: true,
      attributes: true
    });
  }
  mutationHandler(args) {
    const relevant = args.some(
      (mutation) => mutation.type === "childList" || mutation.type === "attributes" && mutation.attributeName === "data-folder-link" || mutation.type === "characterData"
    );
    if (!relevant)
      return;
    if (this.isUpdating)
      return;
    this.isUpdating = true;
    try {
      this.update();
    } finally {
      this.isUpdating = false;
    }
  }
  update() {
    if (this.settings.showInBackLinks) {
      this.debouncedUpdateFolderLinks();
    } else {
      this.removeFolderLinks();
    }
  }
  removeFolderLinks() {
    const itemEls = this.outgoingLink.view.containerEl.querySelectorAll(".outgoing-link-item");
    itemEls.forEach((itemEl) => {
      var _a;
      if ((_a = itemEl.textContent) == null ? void 0 : _a.endsWith("/")) {
        itemEl.remove();
      }
    });
  }
  updateFolderLinks() {
    var _a;
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
    const itemEls = this.outgoingLink.view.containerEl.querySelectorAll(".outgoing-link-item");
    itemEls.forEach((itemEl) => {
      const linkName = itemEl.textContent;
      if ((linkName == null ? void 0 : linkName.endsWith("/")) && this.folderService.currentValue) {
        const folder = this.folderService.currentValue.raw.find(
          (f) => f.path === getPathFromFolder(linkName)
        );
        if (itemEl.dataset.folderLink !== linkName) {
          itemEl.dataset.folderLink = linkName;
        }
        const iconEl = itemEl.querySelector(".tree-item-icon");
        if (folder) {
          const newLabel = this.translationService.getTranslation(
            "plugins.file-explorer.action-reveal-file"
          );
          if (itemEl.ariaLabel !== newLabel) {
            itemEl.ariaLabel = newLabel;
          }
          if (iconEl && iconEl.getAttribute("data-icon") !== "link") {
            (0, import_obsidian3.setIcon)(iconEl, "link");
          }
        } else {
          const newLabel = this.translationService.getTranslation(
            "plugins.outgoing-links.tooltip-not-created"
          );
          if (itemEl.ariaLabel !== newLabel) {
            itemEl.ariaLabel = newLabel;
          }
          if (iconEl && iconEl.getAttribute("data-icon") !== "folder-plus") {
            (0, import_obsidian3.setIcon)(iconEl, "folder-plus");
          }
        }
      }
    });
    this.setupMutationObserver();
  }
  disconnect() {
    var _a;
    (_a = this.mutationObserver) == null ? void 0 : _a.disconnect();
  }
};

// src/settings/default.ts
var DEFAULT_SETTINGS = {
  showInBackLinks: true,
  alwaysUpdate: false
};

// src/settings/SettingsTab.ts
var import_obsidian4 = require("obsidian");
var SettingsTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin, settings) {
    super(app, plugin);
    this.app = app;
    this.plugin = plugin;
    this.settings = settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian4.Setting(containerEl).setName("Show Folder Links in Outgoing Links Tab").addToggle(
      (component) => component.setValue(this.settings.showInBackLinks).onChange(async (value) => {
        this.settings.showInBackLinks = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Automatically update folder links").setDesc("Turn off to be prompted to update links after renaming a folder.").addToggle(
      (component) => component.setValue(this.settings.alwaysUpdate).onChange(async (value) => {
        this.settings.alwaysUpdate = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

// src/services/FolderLinkManager.ts
var import_obsidian5 = require("obsidian");
var FolderLinkManager = class {
  constructor(vault, settingsService, translationService, eventService, modalService, folderService, fileExplorer) {
    this.vault = vault;
    this.settingsService = settingsService;
    this.translationService = translationService;
    this.eventService = eventService;
    this.modalService = modalService;
    this.folderService = folderService;
    this.fileExplorer = fileExplorer;
    this.setupClickListener();
    this.eventService.onVaultEvent("rename" /* Rename */, this.renameAfterUpdateCb.bind(this));
  }
  setupClickListener() {
    this.eventService.onDOMEvent(
      window,
      "click",
      "[data-folder-link]",
      (el, ev) => {
        ev.stopPropagation();
        const existingFolder = this.folderService.currentValue.raw.filter(
          (f) => f.path === getPathFromFolder(el.dataset.folderLink)
        )[0];
        if (existingFolder) {
          this.fileExplorer.view.revealInFolder(existingFolder);
        } else {
          this.folderService.createFolder(getPathFromFolder(el.dataset.folderLink));
        }
      },
      true
    );
  }
  renameAfterUpdateCb(file, oldPath) {
    var _a;
    if (file instanceof import_obsidian5.TFolder) {
      const filesThatLink = this.folderService.getLinkedFiles(oldPath);
      const linksCount = this.folderService.getFolderLinkCountInFiles(filesThatLink, oldPath);
      if (filesThatLink.length) {
        if (this.settingsService.getSetting("alwaysUpdate")) {
          this.renameFolderLinksInFiles(
            filesThatLink,
            getFolderFromPath(file.path),
            getFolderFromPath(oldPath),
            linksCount,
            filesThatLink.length
          );
        } else {
          let modal;
          const modalBody = new DocumentFragment();
          const firstParagraph = document.createElement("p");
          const secondParagraph = document.createElement("p");
          firstParagraph.textContent = this.translationService.getTranslation("dialogue.label-confirm-update-link-to-file").replace(
            this.translationService.getTranslation(
              "plugins.bases.label-file-prop-file"
            ),
            this.translationService.getTranslation(
              "plugins.bases.label-file-prop-folder"
            )
          );
          secondParagraph.textContent = this.translationService.getTranslation(
            "dialogue.label-link-affected",
            {
              links: this.translationService.getTranslation(
                "nouns.link-with-count_plural",
                { count: linksCount.toString() }
              ),
              files: this.translationService.getTranslation(
                "nouns.file-with-count_plural",
                { count: filesThatLink.length.toString() }
              )
            }
          );
          const buttonContainer = document.createElement("div");
          buttonContainer.classList.add("modal-button-container");
          const alwaysUpdateButton = document.createElement("button");
          alwaysUpdateButton.textContent = "Always update";
          alwaysUpdateButton.onclick = async () => {
            await this.renameFolderLinksInFiles(
              filesThatLink,
              getFolderFromPath(file.path),
              getFolderFromPath(oldPath),
              linksCount,
              filesThatLink.length
            );
            await this.settingsService.setSetting("alwaysUpdate", true);
            modal.close();
          };
          buttonContainer.appendChild(alwaysUpdateButton);
          const justOnceButton = document.createElement("button");
          justOnceButton.textContent = "Just once";
          justOnceButton.onclick = async () => {
            await this.renameFolderLinksInFiles(
              filesThatLink,
              getFolderFromPath(file.path),
              getFolderFromPath(oldPath),
              linksCount,
              filesThatLink.length
            );
            modal.close();
          };
          buttonContainer.appendChild(justOnceButton);
          const doNotUpdateButton = document.createElement("button");
          doNotUpdateButton.textContent = "Do not update";
          doNotUpdateButton.onclick = async () => {
            modal.close();
          };
          buttonContainer.appendChild(doNotUpdateButton);
          modalBody.append(firstParagraph, secondParagraph);
          modal = this.modalService.createModal(
            this.translationService.getTranslation("dialogue.label-update-links"),
            modalBody
          );
          (_a = modal.contentEl.parentElement) == null ? void 0 : _a.appendChild(buttonContainer);
          modal.open();
        }
      }
    }
  }
  async renameFolderLinksInFiles(files, newLink, oldLink, linkCount, filesCount) {
    for (const file of files) {
      try {
        const content = await this.vault.read(file);
        const regex = new RegExp(
          `(\\s*\\[\\[\\s*)${escapeRegex(oldLink)}([^\\]]*\\]\\]\\s*)`,
          "g"
        );
        const updatedContent = content.replace(regex, `$1${newLink}$2`);
        if (content !== updatedContent) {
          await this.vault.modify(file, updatedContent);
        }
      } catch (error) {
        throw new Error(`Failed to update links in ${file.path}:`);
      }
    }
    new import_obsidian5.Notice(
      this.translationService.getTranslation("dialogue.msg-updated-links", {
        links: this.translationService.getTranslation("nouns.link-with-count_plural", {
          count: linkCount.toString()
        }),
        files: this.translationService.getTranslation("nouns.file-with-count_plural", {
          count: filesCount.toString()
        })
      })
    );
  }
};

// src/services/ModalService.ts
var import_obsidian6 = require("obsidian");
var ModalService = class {
  constructor(app) {
    this.app = app;
  }
  createModal(title, content) {
    const modal = new import_obsidian6.Modal(this.app);
    modal.setTitle(title).setContent(content);
    return modal;
  }
};

// src/services/TranslationService.ts
var TranslationService = class {
  constructor(i18next) {
    this.i18next = i18next;
    if (!i18next) {
      throw Error("No translations found");
    }
  }
  getTranslation(key, placeholders) {
    return this.i18next.t(key, placeholders);
  }
};

// src/services/SettingsService.ts
var SettingsService = class {
  constructor(plugin, settings) {
    this.plugin = plugin;
    this.settings = settings;
  }
  getSetting(key) {
    return this.settings[key];
  }
  async setSetting(key, value) {
    this.settings[key] = value;
    this.saveSettings();
  }
  async saveSettings() {
    this.plugin.saveSettings();
  }
};

// src/services/WorkspaceService.ts
var WorkspaceService = class {
  constructor(workspace, metadataCache) {
    this.workspace = workspace;
    this.metadataCache = metadataCache;
  }
  getActiveEditor() {
    return this.workspace.activeEditor;
  }
  folderLinksinActiveEditor() {
    const editor = this.getActiveEditor();
    if (!editor || !editor.file) {
      return void 0;
    }
    const unresolvedLinks = this.metadataCache.unresolvedLinks[editor.file.path];
    return Object.keys(unresolvedLinks).filter((key) => key.trim().endsWith("/")).length;
  }
};

// src/main.ts
var FolderLinksPlugin = class extends import_obsidian7.Plugin {
  onload() {
    try {
      this.setup();
    } catch (error) {
      if (error instanceof UserHandableError) {
        showErrorNotice(error.message);
      } else {
        showErrorNotice("An internal error occured.");
      }
    }
  }
  async setup() {
    await this.setupSettings();
    this.initServices();
    await this.eventService.waitForLayoutReady();
    this.setupFileExplorer();
    this.initServices();
    this.initDependentServices();
    this.setupCorePluginWatchers();
    this.registerMarkdownPostProcessor(folderLinkPostProcessor(this.folderService.observable));
    this.registerEditorExtension([
      folderUpdater(this.folderService.observable),
      folderField,
      folderMarkPlugin
    ]);
    this.folderService.observable.subscribe(() => {
      if (this.graphViewManager) {
        this.graphViewManager.update();
      }
    });
  }
  async setupSettings() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this, this.settings));
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  initServices() {
    this.settingsService = new SettingsService(this, this.settings);
    this.workspaceService = new WorkspaceService(this.app.workspace, this.app.metadataCache);
    this.translationService = new TranslationService(window.i18next);
    this.eventService = new EventService(this);
    this.modalService = new ModalService(this.app);
    this.corePluginService = new CorePluginService(this.app.workspace);
    this.folderService = new FolderService(
      this.app.vault,
      this.app.metadataCache,
      this.eventService
    );
  }
  setupFileExplorer() {
    const instances = this.corePluginService.getInstancesImmediate(
      "file-explorer" /* FileExplorer */
    );
    if (instances.length === 0) {
      throw new UserHandableError(
        "No file explorer plugin found. Is the core plugin enabled?"
      );
    } else if (instances.length > 1) {
      throw new Error("More than one file explorer plugin found. Undefined state.");
    }
    this.obsidianFileExplorer = instances[0];
  }
  initDependentServices() {
    this.folderLinkManager = new FolderLinkManager(
      this.app.vault,
      this.settingsService,
      this.translationService,
      this.eventService,
      this.modalService,
      this.folderService,
      this.obsidianFileExplorer
    );
    this.graphViewManager = new GraphViewManager(this.folderService, this.obsidianFileExplorer);
  }
  setupCorePluginWatchers() {
    this.corePluginService.registerWatcher(
      "outgoing-link" /* OutgoingLink */,
      (leaf) => {
        this.obsidianOutgoingLink = leaf;
        this.outgoingLinkManager = new OutgoingLinkmanager(
          this.translationService,
          this.folderService,
          this.obsidianOutgoingLink,
          this.settings
        );
      },
      () => {
        var _a;
        this.obsidianOutgoingLink = void 0;
        (_a = this.outgoingLinkManager) == null ? void 0 : _a.disconnect();
        this.outgoingLinkManager = void 0;
      }
    );
    this.corePluginService.registerWatcher(
      "graph" /* GraphView */,
      (leaf) => {
        this.graphViewManager.addInstance(leaf);
      },
      (leaf) => {
        this.graphViewManager.removeInstance(leaf);
      },
      (leaf) => {
        this.graphViewManager.updateInstance(leaf);
      },
      true
    );
  }
};


/* nosourcemap */