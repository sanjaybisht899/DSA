
---

## **97. Interleaving String**

### **Hints**
1. **Length Check** – If `s3.length() != s1.length() + s2.length()`, return `false`.
2. Think in **3 pointers**:
    - `index1` → current position in `s1`
    - `index2` → current position in `s2`
    - `index3` → current position in `s3`
3. At each step:
    - If `s3[index3] == s1[index1]`, try moving in `s1`.
    - If `s3[index3] == s2[index2]`, try moving in `s2`.
4. Base Case → when all indexes reach the end, return `true`.
5. Always **check index bounds** before `charAt()`.
6. Use dp(index1)(index2) to memoize and avoid recomputation.
7. **Space optimization** possible: store only the latest state.

---

## **1. Recursive (Brute Force)** – O(2^(n1+n2)) Time, O(n1+n2) Space

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length();
        int n2 = s2.length();
        int n3 = s3.length();
        if (n3 != n1 + n2) return false;
        return helper(s3, 0, s1, 0, s2, 0);
    }

    boolean helper(String s3, int index3, String s1, int index1, String s2, int index2) {
        if (index3 == s3.length() && index1 == s1.length() && index2 == s2.length()) 
            return true;
        if (index1 > s1.length() || index2 > s2.length() || index3 >= s3.length()) 
            return false;

        boolean match1 = false, match2 = false;

        if (index1 < s1.length() && s3.charAt(index3) == s1.charAt(index1))
            match1 = helper(s3, index3 + 1, s1, index1 + 1, s2, index2);

        if (index2 < s2.length() && s3.charAt(index3) == s2.charAt(index2))
            match2 = helper(s3, index3 + 1, s1, index1, s2, index2 + 1);

        return match1 || match2;
    }
}
```

---

## **2. DP with Memoization** – O(n1 × n2) Time, O(n1 × n2) Space

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length();
        int n2 = s2.length();
        int n3 = s3.length();
        if (n3 != n1 + n2) return false;

        Boolean[][] dp = new Boolean[n1 + 1][n2 + 1];
        return helper(s3, 0, s1, 0, s2, 0, dp);
    }

    boolean helper(String s3, int index3, String s1, int index1, String s2, int index2, Boolean[][] dp) {
        if (index3 == s3.length() && index1 == s1.length() && index2 == s2.length()) 
            return true;
        if (index1 > s1.length() || index2 > s2.length() || index3 >= s3.length()) 
            return false;

        if (dp[index1][index2] != null) return dp[index1][index2];

        boolean match1 = false, match2 = false;

        if (index1 < s1.length() && s3.charAt(index3) == s1.charAt(index1))
            match1 = helper(s3, index3 + 1, s1, index1 + 1, s2, index2, dp);

        if (index2 < s2.length() && s3.charAt(index3) == s2.charAt(index2))
            match2 = helper(s3, index3 + 1, s1, index1, s2, index2 + 1, dp);

        return dp[index1][index2] = match1 || match2;
    }
}
```

---

## **3. Space-Optimized DP** – O(n1 × n2) Time, O(min(n1, n2)) Space

```java
class Solution {
    public boolean isInterleave(String s1, String s2, String s3) {
        int n1 = s1.length();
        int n2 = s2.length();
        if (s3.length() != n1 + n2) return false;

        if (n2 > n1) return isInterleave(s2, s1, s3); // ensure s2 is smaller

        boolean[] dp = new boolean[n2 + 1];
        dp[0] = true;

        for (int index2 = 1; index2 <= n2; index2++) {
            dp[index2] = dp[index2 - 1] && s2.charAt(index2 - 1) == s3.charAt(index2 - 1);
        }

        for (int index1 = 1; index1 <= n1; index1++) {
            dp[0] = dp[0] && s1.charAt(index1 - 1) == s3.charAt(index1 - 1);
            for (int index2 = 1; index2 <= n2; index2++) {
                dp[index2] = (dp[index2] && s1.charAt(index1 - 1) == s3.charAt(index1 + index2 - 1))
                          || (dp[index2 - 1] && s2.charAt(index2 - 1) == s3.charAt(index1 + index2 - 1));
            }
        }
        return dp[n2];
    }
}
```

---

### **Key Points with Your Variable Names**

- `index1`, `index2`, `index3` → track position in `s1`, `s2`, `s3`.
- Base Case → all indexes reach the end → `true`.
- Bounds check before `charAt()` to avoid `StringIndexOutOfBounds`.
- In DP, `dp[index1][index2]` stores whether `s3[index1+index2...]` can be formed from `s1[index1...]` and `s2[index2...]`.
- Space optimization → use `boolean[] dp` and update row by row.

---
