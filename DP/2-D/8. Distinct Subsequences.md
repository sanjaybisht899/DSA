**Problem**: Count how many distinct subsequences of string `s` equal string `t`.  
LeetCode #115

---

### **Recursive Logic**

We solve by comparing characters from both strings using two pointers (`index1` for `s`, `index2` for `t`):

1. **Base Cases**
    - If `index2 == t.length()` → fully matched `t` → return `1` (valid subsequence found).
    - If `index1 == s.length()` → `s` ended before matching `t` → return `0` (no match possible).
2. **Choices**
    - **If characters match** (`s.charAt(index1) == t.charAt(index2)`):
        - Take the match → move both pointers (`index1+1, index2+1`).
        - Skip the match → move only `index1` (`index1+1, index2`).
    - **If characters don't match**:
        - Must skip current char in `s` → move `index1+1, index2`.
3. **Sum results** from the choices → total distinct subsequences.

---

### **Code (Recursive)**

```java
class Solution {
    public int numDistinct(String s, String t) {
        if (t.length() > s.length()) return 0;
        return helper(s, t, 0, 0);
    }

    public int helper(String s, String t, int index1, int index2) {
        if (index2 == t.length()) return 1; // matched entire t
        if (index1 == s.length()) return 0; // s ended

        int ans = 0;
        if (s.charAt(index1) == t.charAt(index2)) {
            ans += helper(s, t, index1 + 1, index2 + 1); // take match
        }
        ans += helper(s, t, index1 + 1, index2); // skip s[index1]

        return ans;
    }
}
```

---

### **Why this works**

We explore **all subsequences** of `s` using recursion and count only those that match `t`.  
The key is **two pointers** moving independently — one for `s`, one for `t`.

---

### **Pattern Spotting Template**

You’ll see this exact recursion in problems where:

- You **count** the number of ways to match/transform a smaller string into another (or form a target).
- You have **two strings/arrays** and need to explore both simultaneously.
- Base cases are:
    
    ```
    if (index2 == target.length) → return 1;
    if (index1 == source.length) → return 0;
    ```
    
- Choices:
    
    ```
    if match → take both + skip s
    if not match → skip s
    ```
    

**Examples with same pattern:**

- Count subsequences equal to target (this problem)
- Count ways to interleave strings
- Count distinct subsequences with constraints
- Wildcard matching (variation in boolean form)

---
