
---

# Sumit Notes

Difference between coin change I & II - is here we can't take duplicate as we have to maintain or give combinations


### Recursive (Brute Force â€“ No Memo)

```java
int change(int amount, int[] coins) {
    return helper(coins, amount, 0);
}

int helper(int[] coins, int amount, int index) {
    if (amount == 0) return 1;
    if (index >= coins.length || amount < 0) return 0;

    // Two choices: take the coin or skip it
    int take = helper(coins, amount - coins[index], index);     // use current coin again
    int skip = helper(coins, amount, index + 1);                // move to next coin

    return take + skip;
}
```



Recursive Memoization

```java
class Solution {
    public int change(int amount, int[] coins) {
        Integer[][] dp = new Integer[amount + 1][coins.length + 1];
        return helper(coins, amount, 0, dp);
    }

    public int helper(int[] coins, int amount, int index, Integer[][] dp) {
        if (amount == 0) return 1;
        if (index >= coins.length || amount < 0) return 0;

        if (dp[amount][index] != null) return dp[amount][index];

        // Two choices: take the coin or skip it
        int take = helper(coins, amount - coins[index], index, dp);     // take same coin again
        int skip = helper(coins, amount, index + 1, dp);               // skip to next coin

        return dp[amount][index] = take + skip;
    }
}
```

Recursion Tree

[[448efa417a8da802678696f46a808dab_MD5.jpeg|Open: Pasted image 20250808093752.png]]
![[448efa417a8da802678696f46a808dab_MD5.jpeg]]


---

