
---

**Goal:**  
Find the length of the longest increasing path in a matrix (move only up, down, left, right).  

---

### 1. Recursive DFS (Brute Force – No Memoization)  
- For each cell, explore in all 4 directions.  
- Only move to cells with strictly greater values.  
- Keep track of the longest path found.  

```java
int longestIncreasingPath(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length;
    int max = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            max = Math.max(max, helper(matrix, i, j));
        }
    }
    return max + 1; // +1 because helper counts edges, not nodes
}

int helper(int[][] matrix, int x, int y) {
    int m = matrix.length, n = matrix[0].length;
    int temp = 0;
    int curr = matrix[x][y];
    int[] dirx = {-1, 1, 0, 0};
    int[] diry = {0, 0, -1, 1};

    for (int i = 0; i < 4; i++) {
        int nx = x + dirx[i];
        int ny = y + diry[i];
        if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
        if (matrix[nx][ny] > curr) {
            temp = Math.max(temp, 1 + helper(matrix, nx, ny));
        }
    }
    return temp;
}
```

**Complexity:**  
- Time: `O(4^(m*n))` worst case (explores all paths).  
- Space: `O(m*n)` recursion depth in worst case.  

---

### 2. Recursive DFS + Memoization (Top-Down DP)  
- Same DFS, but store results in a `dp` array.  
- Each cell’s longest path is computed once.  

```java
int longestIncreasingPath(int[][] matrix) {
    int m = matrix.length, n = matrix[0].length;
    Integer[][] dp = new Integer[m][n];
    int max = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            max = Math.max(max, helper(matrix, i, j, dp));
        }
    }
    return max + 1;
}

int helper(int[][] matrix, int x, int y, Integer[][] dp) {
    if (dp[x][y] != null) return dp[x][y];

    int m = matrix.length, n = matrix[0].length;
    int temp = 0;
    int curr = matrix[x][y];
    int[] dirx = {-1, 1, 0, 0};
    int[] diry = {0, 0, -1, 1};

    for (int i = 0; i < 4; i++) {
        int nx = x + dirx[i];
        int ny = y + diry[i];
        if (nx < 0 || ny < 0 || nx >= m || ny >= n) continue;
        if (matrix[nx][ny] > curr) {
            temp = Math.max(temp, 1 + helper(matrix, nx, ny, dp));
        }
    }
    return dp[x][y] = temp;
}
```

**Complexity:**  
- Time: `O(m*n)` (each cell computed once).  
- Space: `O(m*n)` for `dp` + recursion stack.  

---
