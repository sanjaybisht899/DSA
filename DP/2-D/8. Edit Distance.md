
---
**Problem:**

Given two strings word1 and word2, find the minimum number of operations required to convert word1 to word2. Allowed operations: insert, delete, replace.

**Hints / Pattern Recognition:**
- This is a **string transformation problem** where each operation affects the index movement differently.
- Template pattern: two string indices moving independently → often solved using recursion + memoization or bottom-up DP.
- Key condition: If characters match, move both indices without cost. Otherwise, try all three operations and take the minimum.
- Recurrence relation:
```
if word1[i] == word2[j]:
    dp[i][j] = dp[i+1][j+1]
else:
    dp[i][j] = 1 + min(
        dp[i][j+1],   // insert
        dp[i+1][j],   // delete
        dp[i+1][j+1]  // replace
    )
```
- Base cases:
  - If index1 == len(word1): Remaining characters in word2 must be inserted.
  - If index2 == len(word2): Remaining characters in word1 must be deleted.

**Recursive Approach (No Memoization):**
```java
class Solution {
    public int minDistance(String word1, String word2) {
        return helper(word1, 0, word2, 0);
    }
    public int helper(String word1, int index1, String word2, int index2) {
        int n1 = word1.length();
        int n2 = word2.length();
        if (index1 == n1) return n2 - index2; // insert rest of word2
        if (index2 == n2) return n1 - index1; // delete rest of word1
        if (word1.charAt(index1) == word2.charAt(index2)) {
            return helper(word1, index1 + 1, word2, index2 + 1);
        } else {
            int insert = 1 + helper(word1, index1, word2, index2 + 1);
            int delete = 1 + helper(word1, index1 + 1, word2, index2);
            int replace = 1 + helper(word1, index1 + 1, word2, index2 + 1);
            return Math.min(insert, Math.min(delete, replace));
        }
    }
}
```

**Approach Progression:**
1. **Recursive** – try all paths, exponential complexity.
2. **Recursive + Memoization** – store results for `(i, j)` to avoid recomputation, O(n*m) time.
3. **Bottom-up Tabulation** – fill DP table from the base cases upward.
4. **Space Optimization** – reduce to O(min(n, m)) space using rolling arrays.
