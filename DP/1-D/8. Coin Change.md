
---
#  Sumit Notes

1. Take/not take( via aman approach) approach will take 2d dp
2. Follow this for 1-d dp



---

# Sanjay Notes

### 322. Coin Change 

#### Problem
You are given coins of different denominations and a total amount. Return the fewest number of coins needed to make up that amount. If it's not possible, return -1.

#### Hint / Approach
Try all combinations of coins using recursion. Then optimize with memoization. Finally, use a bottom-up approach (tabulation) for best performance.

---

#### 1. Recursive (Brute Force â€“ No Memo)

```java
int coinChange(int[] coins, int amount) {
    if (amount == 0) return 0;
    if (amount < 0) return Integer.MAX_VALUE;

    int min = Integer.MAX_VALUE;
    for (int coin : coins) {
        int res = coinChange(coins, amount - coin);
        if (res != Integer.MAX_VALUE) {
            min = Math.min(min, 1 + res);
        }
    }
    return min;
}
```

---

#### 2. DP with HashMap (Top-Down Memoization)

```java
HashMap<Integer,Integer> map = new HashMap<>();

int coinChange(int[] coins, int amount) {
    int result = helper(coins, amount);
    return (result == Integer.MAX_VALUE) ? -1 : result;
}

int helper(int[] coins, int amount) {
    if (map.containsKey(amount)) return map.get(amount);
    if (amount == 0) return 0;

    int coin = Integer.MAX_VALUE;
    for (int c : coins) {
        int rem = amount - c;
        if (rem >= 0) {
            int res = helper(coins, rem);
            if (res != Integer.MAX_VALUE) {
                coin = Math.min(coin, 1 + res);
            }
        }
    }
    map.put(amount, coin);
    return coin;
}
```

---

#### 3. 1D DP with Array Memoization (Top-Down)

```java
int[] dp;

int coinChange(int[] coins, int amount) {
    dp = new int[amount + 1];
    Arrays.fill(dp, -1);
    int ans = coinCount(coins, amount);
    return (ans == Integer.MAX_VALUE) ? -1 : ans;
}

int coinCount(int[] coins, int amount) {
    if (amount == 0) return 0;
    if (amount < 0) return Integer.MAX_VALUE;
    if (dp[amount] != -1) return dp[amount];

    int minCoins = Integer.MAX_VALUE;
    for (int c : coins) {
        int res = coinCount(coins, amount - c);
        if (res != Integer.MAX_VALUE) {
            minCoins = Math.min(minCoins, 1 + res);
        }
    }
    return dp[amount] = minCoins;
}
```

---

#### 4. Bottom-Up Tabulation (1D DP)

```java
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;

    for (int i = 1; i <= amount; i++) {
        for (int c : coins) {
            if (i - c >= 0) {
                dp[i] = Math.min(dp[i], 1 + dp[i - c]);
            }
        }
    }

    return (dp[amount] > amount) ? -1 : dp[amount];
}
```


---