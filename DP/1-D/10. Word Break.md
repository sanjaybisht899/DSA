
---

## Problem: Word Break

### How to Solve

- We need to check if string `s` can be segmented into words from the given dictionary.
- Try every prefix of `s`. If prefix is in dictionary, recursively check the remaining string.
- Use memoization to avoid recomputation.
- Convert recursion â†’ DP (bottom-up).

---

### Recursive (Brute Force)

```java
boolean helper(String s, List<String> dict) {
    if (s.equals("")) return true;
    for (String word : dict) {
        if (s.startsWith(word) && helper(s.substring(word.length()), dict)) 
            return true;
    }
    return false;
}
```

- Time: O(2^n)
- Space: O(n) recursion depth

---

### Recursive + Memoization (Top Down)

```java
boolean helper(String s, List<String> dict, Map<String, Boolean> dp) {
    if (s.equals("")) return true;
    if (dp.containsKey(s)) return dp.get(s);
    for (String word : dict) {
        if (s.startsWith(word) && helper(s.substring(word.length()), dict, dp)) {
            dp.put(s, true);
            return true;
        }
    }
    dp.put(s, false);
    return false;
}
```

- Time: O(n^2) (checking substrings)
- Space: O(n) recursion + O(n) map

---

### DP (Bottom Up)

```java
boolean wordBreak(String s, List<String> dict) {
    Set<String> set = new HashSet<>(dict);
    boolean[] dp = new boolean[s.length()+1];
    dp[0] = true;
    for (int i = 1; i <= s.length(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && set.contains(s.substring(j, i))) {
                dp[i] = true;
                break;
            }
        }
    }
    return dp[s.length()];
}
```

- Time: O(n^2)
- Space: O(n)

---

