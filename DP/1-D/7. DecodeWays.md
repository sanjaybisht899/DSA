1. Recursion - https://www.youtube.com/watch?v=FEkZxCl_-ik
2. Memo - https://leetcode.com/problems/decode-ways/solutions/4454173/recursive-top-down-bottom-up-clean-and-commented-code-dynamic-programming 
3. Tabulation - https://www.youtube.com/watch?v=FEkZxCl_-ik 

---
### Decode Ways

**Problem:**  
Given a string of digits, count how many ways it can be decoded where `'1' -> A, '2' -> B, ..., '26' -> Z`.

---

### Recursive Approach (Top-down)

- Base case: if `i == n` → return 1 (end reached).
- If `s[i] == '0'` → return 0 (cannot decode).
- Recursive choices:
    1. Take one digit → recurse on `i+1`.
    2. Take two digits (if ≤ 26 and valid) → recurse on `i+2`.

**Snippet:**

```java
int helper(String s, int i) {
    if (i == s.length()) return 1;
    if (s.charAt(i) == '0') return 0;

    int ways = helper(s, i+1);  
    if (i+1 < s.length() && 
        Integer.parseInt(s.substring(i,i+2)) <= 26) {
        ways += helper(s, i+2);
    }
    return ways;
}
```

---

### DP with Memoization (Top-down with cache)

- Same recursion, but store results in `dp[i]`.
- Avoids recalculating subproblems.

**Snippet:**

```java
int helper(String s, int i, int[] dp) {
    if (i == s.length()) return 1;
    if (s.charAt(i) == '0') return 0;
    if (dp[i] != -1) return dp[i];

    int ways = helper(s, i+1, dp);
    if (i+1 < s.length() && 
        Integer.parseInt(s.substring(i,i+2)) <= 26) {
        ways += helper(s, i+2, dp);
    }
    return dp[i] = ways;
}
```


---
