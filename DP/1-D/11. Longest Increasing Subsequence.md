

---

**1. Problem Statement**  
Given an integer array `nums`, return the length of the longest strictly increasing subsequence.


**2. How to Solve (step-by-step logic)**

- Choose each element and try to build increasing subsequences.
- Compare with later elements to extend subsequence.
- Use recursion → memoization → DP → Binary Search optimization.

---
### Brute Force (Recursive DFS)

**Steps:**

1. Start from each index.
2. Explore all subsequences.
3. Return max length found.

**Snippet:**

```java
int dfs(int[] nums, int i, int prev) {
    if (i == nums.length) return 0;
    int take = 0;
    if (nums[i] > prev) 
        take = 1 + dfs(nums, i+1, nums[i]);
    int skip = dfs(nums, i+1, prev);
    return Math.max(take, skip);
}
```

**Time:** O(2^n)  
**Space:** O(n) recursion

---

### Better (Recursion + Memoization: Top-Down DP)

**Steps:**

1. Use `dp[index][prevIndex]` to avoid recomputation.
2. Either take current element (if valid) or skip.

**Snippet:**

```java
int dfs(int[] nums, int i, int prevIdx, int[][] dp) {
    if (i == nums.length) return 0;
    if (dp[i][prevIdx+1] != -1) return dp[i][prevIdx+1];
    int take = 0;
    if (prevIdx == -1 || nums[i] > nums[prevIdx])
        take = 1 + dfs(nums, i+1, i, dp);
    int skip = dfs(nums, i+1, prevIdx, dp);
    return dp[i][prevIdx+1] = Math.max(take, skip);
}
```

**Time:** O(n²)  
**Space:** O(n²)

---

### Optimal DP (Bottom-Up)

**Steps:**

1. Create dp[] of size n.
2. dp[i] = LIS ending at index i.
3. For each i, check all j < i.
4. If nums[i] > nums[j], update dp[i] = max(dp[i], dp[j] + 1).
5. Answer = max(dp[]).

**Snippet:**

```java
int LIS(int[] nums) {
    int n = nums.length, ans = 1;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    for (int i=0; i<n; i++) {
        for (int j=0; j<i; j++) {
            if (nums[i] > nums[j])
                dp[i] = Math.max(dp[i], dp[j]+1);
        }
        ans = Math.max(ans, dp[i]);
    }
    return ans;
}
```

**Time:** O(n²)  
**Space:** O(n)

---

### Most Optimal (Binary Search + Greedy)

**Steps:**

1. Use an array `sub`.
2. For each num:
    - If num > last element in sub → append.
    - Else → replace first element >= num (binary search).
3. Length of `sub` = LIS length.

**Snippet:**

```java
int LIS(int[] nums) {
    List<Integer> sub = new ArrayList<>();
    for (int num : nums) {
        int i = Collections.binarySearch(sub, num);
        if (i < 0) i = -(i+1);
        if (i == sub.size()) sub.add(num);
        else sub.set(i, num);
    }
    return sub.size();
}
```

**Time:** O(n log n)  
**Space:** O(n)

Must Watch : https://www.youtube.com/watch?v=on2hvxBXJH4 for Binary Search Explanation 

---
