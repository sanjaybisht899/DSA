1. Brute force with O(n^2)
2. intuitive approach of -ve , +ve & zero By striver -
                https://leetcode.com/problems/maximum-product-subarray/submissions/1716553340
3. Kadane's algo

---
### Max Product Subarray

#### Key Idea

At every index, track both `max` and `min` product because:

- Negative × Negative = Positive
- Negative × Positive = Negative  
    This helps handle sign flips.

---

### Recursive Approach

- Base case: end of array → return `(1,1)`
- At each step:
    
    - Multiply current element with `next.min` and `next.max`
    - Update `minHere` and `maxHere`
    - Update global `max`

```java
// recursive helper
Pair helper(int[] nums, int index) {
    if (index == nums.length) return new Pair(1,1);

    Pair next = helper(nums, index+1);
    int curr = nums[index];

    int a = curr * next.min;
    int b = curr * next.max;

    int minHere = Math.min(curr, Math.min(a,b));
    int maxHere = Math.max(curr, Math.max(a,b));

    max = Math.max(max, maxHere);
    return new Pair(minHere, maxHere);
}
```

- **Time Complexity:** O(n) (each index visited once)
- **Space Complexity:** O(n) (recursion stack)

---

### DP (Optimal Iterative Approach)

- Use two variables: `currMax`, `currMin`
- Swap if number is negative
- Update using `Math.max/Math.min`
- Keep track of global max

```java
int maxProduct(int[] nums) {
    int currMax = nums[0], currMin = nums[0], res = nums[0];

    for (int i = 1; i < nums.length; i++) {
        if (nums[i] < 0) {
            int temp = currMax;
            currMax = currMin;
            currMin = temp;
        }
        currMax = Math.max(nums[i], currMax * nums[i]);
        currMin = Math.min(nums[i], currMin * nums[i]);

        res = Math.max(res, currMax);
    }
    return res;
}
```

- **Time Complexity:** O(n)
- **Space Complexity:** O(1)

---

