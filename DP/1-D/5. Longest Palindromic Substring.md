
# Sumit Notes


Palindrome - that reads similar when read from forward & backward

String str = "sumit";
Total substrings=  n(n+1)/2 ~= n2
Total subsequences=2^n , where n = length of string

Total substrings	15 (non-empty) or 16 (with empty)
Total subsequences	32 (including empty)
Non-empty subsequences	31

**Question-**  [https://leetcode.com/problems/longest-palindromic-substring/solutions/4212564/beats-96-49-5-different-approaches-brute-force-eac-dp-ma-recursion/](https://leetcode.com/problems/longest-palindromic-substring/solutions/4212564/beats-96-49-5-different-approaches-brute-force-eac-dp-ma-recursion/)

USe this for better DP

---
# Sanjay Notes

### 5. Longest Palindromic Substring – Cleaned Up Notes (Java)

#### Problem
Given a string `s`, return the longest palindromic substring in `s`.

#### Hint / Approach
Try checking all substrings using recursion. Optimize using DP
Most efficient method is expand around center using two pointers.

If I'm solving this using DP there is 


---

#### 1. Recursive (Brute Force – No Memo)

```java
boolean isPalindrome(String s, int i, int j) {
    while (i < j) {
        if (s.charAt(i) != s.charAt(j)) return false;
        i++;
        j--;
    }
    return true;
}

String longestPalindrome(String s) {
    int maxLen = 0;
    String result = "";

    for (int i = 0; i < s.length(); i++) {
        for (int j = i; j < s.length(); j++) {
            if (isPalindrome(s, i, j) && j - i + 1 > maxLen) {
                maxLen = j - i + 1;
                result = s.substring(i, j + 1);
            }
        }
    }
    return result;
}
```

---

#### 2. DP (Top-Down Recursion with Memoization)

```java
Map<String, Boolean> memo = new HashMap<>();

boolean isPalindrome(String s, int i, int j) {
    String key = i + "," + j;
    if (memo.containsKey(key)) return memo.get(key);

    while (i < j) {
        if (s.charAt(i) != s.charAt(j)) {
            memo.put(key, false);
            return false;
        }
        i++;
        j--;
    }
    memo.put(key, true);
    return true;
}
```

---

#### 3. Tabulation (Bottom-Up DP)

```java
String longestPalindrome(String s) {
    int n = s.length();
    boolean[][] dp = new boolean[n][n];
    int start = 0, maxLen = 1;

    for (int i = 0; i < n; i++) {
        dp[i][i] = true;
    }

    for (int len = 2; len <= n; len++) {
        for (int i = 0; i <= n - len; i++) {
            int j = i + len - 1;
            if (s.charAt(i) == s.charAt(j)) {
                if (len == 2 || dp[i + 1][j - 1]) {
                    dp[i][j] = true;
                    if (len > maxLen) {
                        start = i;
                        maxLen = len;
                    }
                }
            }
        }
    }
    return s.substring(start, start + maxLen);
}
```

---

#### 4. Expand Around Center (Two Pointer – Optimal)

```java
String longestPalindrome(String s) {
    int start = 0, end = 0;

    for (int i = 0; i < s.length(); i++) {
        int len1 = expand(s, i, i);     // odd length
        int len2 = expand(s, i, i + 1); // even length
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

int expand(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        left--;
        right++;
    }
    return right - left - 1;
}
```
