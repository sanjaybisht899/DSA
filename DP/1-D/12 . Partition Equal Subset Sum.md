
---

**1. Problem Statement**  
Given an array of positive integers, return true if the array can be partitioned into two subsets such that the sums of elements in both subsets are equal.

---

**2. How to Solve (step-by-step)**

- Find total sum of elements.
- If sum is odd → cannot partition → return false.
- Target = sum/2.
- Problem reduces to: **subset sum problem → can we form subset with sum = target?**
- Solve using recursion, then optimize with memoization/DP.

---

**3. Approaches**

### Brute Force (Recursion)

- Try to include or exclude each element.
- Base: if target becomes 0 → true.
- If index out of bounds or target < 0 → false.

**Code Snippet:**

```java
boolean canPartition(int[] nums, int sum, int i) {
    if (sum == 0) return true;
    if (i == nums.length || sum < 0) return false;
    return canPartition(nums, sum-nums[i], i+1) ||
           canPartition(nums, sum, i+1);
}
```

**Time:** O(2^n)  
**Space:** O(n) (recursion stack)

---

### Better Approach (Recursion + Memoization)

- Store results in `dp[index][sum]`.
- Avoids recomputation.

**Steps:**

1. If target == 0 → true.
2. If index == n or target < 0 → false.
3. Check dp before computing.
4. Include or exclude element.

**Code Snippet:**

```java
boolean helper(int i, int sum, int[] nums, int[][] dp) {
    if (sum == 0) return true;
    if (i == nums.length || sum < 0) return false;
    if (dp[i][sum] != -1) return dp[i][sum] == 1;
    boolean include = helper(i+1, sum-nums[i], nums, dp);
    boolean exclude = helper(i+1, sum, nums, dp);
    dp[i][sum] = (include || exclude) ? 1 : 0;
    return dp[i][sum] == 1;
}
```

**Time:** O(n * sum/2)  
**Space:** O(n * sum/2) + recursion stack

---
